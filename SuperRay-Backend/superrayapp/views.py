from rest_framework import generics
from rest_framework.response import Response
from django.http import HttpResponse
from rest_framework.views import APIView
from rest_framework import status
from rest_framework.decorators import api_view, permission_classes
import cv2
import numpy as np
from .functions import inference, getImgClass, detect_fractures
from django.core.files.base import ContentFile
import base64
from rest_framework_simplejwt.views import TokenObtainPairView
from rest_framework.permissions import AllowAny, IsAuthenticated
from rest_framework_simplejwt.tokens import RefreshToken

# Import your serializers
from .serializers import MyTokenObtainPairSerializer, RegisterSerializer, ProfileSerializer, ReportSerializer

# Import your models if not already imported
from .models import CustomUser, Report


# Create your views here.


# Login User
class MyTokenObtainPairView(TokenObtainPairView):
    serializer_class = MyTokenObtainPairSerializer

# Register User
class RegisterView(generics.CreateAPIView):
    queryset = CustomUser.objects.all()
    permission_classes = (AllowAny,)
    serializer_class = RegisterSerializer

# Log out
class LogoutView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            refresh_token = request.data["refresh_token"]
            token = RefreshToken(refresh_token)
            token.blacklist()
            return Response({"message": "Successfully logged out."}, status=status.HTTP_205_RESET_CONTENT)
        except Exception as e:
            return Response({"error": "Invalid refresh token."}, status=status.HTTP_400_BAD_REQUEST)



# API to get user profile
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def getProfile(request):
    user = request.user
    serializer = ProfileSerializer(user)
    return Response(serializer.data)

# API to update user profile
@api_view(['PUT'])
@permission_classes([IsAuthenticated])
def updateProfile(request):
    user = request.user
    serializer = ProfileSerializer(user, data=request.data, partial=True)
    if serializer.is_valid():
        serializer.save()
    return Response(serializer.data)



#reports generated by a user
@api_view(['GET'])
@permission_classes([IsAuthenticated])
def getReports(request):
    user_reports = Report.objects.filter(user=request.user).order_by('id')
    serializer = ReportSerializer(user_reports, many=True)
    return Response(serializer.data)



#super resolution view
@api_view(['POST'])
def SuperResolutionAPI(request):
    if request.method == 'POST':
        
        image_file = request.FILES.get('image')
        
        if not image_file:
            return Response({'error': 'Image file is required.'}, status=400)
        
        try:
            
            image = cv2.imdecode(np.fromstring(image_file.read(), np.uint8), cv2.IMREAD_COLOR)

            # function checks if the image is of xray or just random image
            classify_image = getImgClass(image)
            if (classify_image == "negative"):
                print('error: Medical Image is allowed only')
                return Response({'error': 'Medical Image is allowed only'}, status=403)
            
   
            # upscale and inference with llm
            upscaled_image, report = inference(image, classify_image)
            print(report)
            
             # Convert image to byte data
            _, buffer = cv2.imencode('.jpeg', upscaled_image)
            image_bytes = buffer.tobytes()
            
            # Encode image data as base64
            base64_image = base64.b64encode(image_bytes).decode('utf-8')
            

            return Response({'image': base64_image,
                             'xreport': report})
        
        except Exception as e:
            return Response({'error': str(e)}, status=500)
        
       
        
        
        
        
    #detect fracture view     
@api_view(['POST'])
def FractureDetectionAPI(request):
    if request.method == 'POST':
        
        image_file = request.FILES.get('image')
        
        if not image_file:
            return Response({'error': 'Image file is required.'}, status=400)
        
        try:
            
            image = cv2.imdecode(np.fromstring(image_file.read(), np.uint8), cv2.IMREAD_COLOR)

            #function checks if the image is of xray or just random image
            classify_image = getImgClass(image)
            if (classify_image == "negative"):
                print('error: Medical Image is allowed only')
                return Response({'error': 'Medical Image is allowed only'}, status=403)
            
            print(classify_image)
            # Upscale ka function
            upscaled_image = upscaleimg(image, classify_image)
            detection_image = detect_fractures(upscaled_image)
            
             # Convert image to byte data
            _, buffer = cv2.imencode('.jpeg', detection_image)
            image_bytes = buffer.tobytes()
            
            # Encode image data as base64
            base64_image = base64.b64encode(image_bytes).decode('utf-8')
            
            return Response({'image': base64_image})
        
        except Exception as e:
            return Response({'error': str(e)}, status=500)

""" @api_view(['GET','POST'])
def SuperResolutionAPI(request):
    return Response('hello') """
